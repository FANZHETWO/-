##### CSS渲染的特点
加载CSS资源时，浏览器将不会渲染任何已处理的内容，直至CSSOM构建完毕。HTML和CSS都是阻塞渲染的资源。所以优化的空间就是尽早、 尽快的下载都客户端，以便缩短首次渲染的时间。

**通过media修改渲染方式**

**注意点**
- 尽可能避免写具体的ＣＳＳ选择器，同时ＴＨＭＬ少写无意义的标签，保证层级扁平。

##### 浏览器渲染页面的几个步骤
1、处理HTML标记并构建DOM树。
2、处理CSS标记并构建CSSOM树。
3、将DOM与CSSOM合并成一个渲染树。
4、根据渲染树来布局，以计算每个节点的几何信息。
5、将各个节点绘制到屏幕上。

**优化的关键路径就是最大限度缩短执行上述1-5步所要消耗的时间。**

- DOM和CSSOM合并成如下图

  ![render tree](https://developers.google.cn/web/fundamentals/performance/critical-rendering-path/images/render-tree-construction.png)

**构建渲染树的过程**
1、从 DOM树的根节点开始遍历每个可见节点。
- 某些节点不可见（例如脚本标记、元标记），因为它们不会体现在渲染输出中，所以会被忽略。
- 某些节点通过CSS隐藏，因此在渲染树中也会被忽略。**比如要是设置了display:none属性，就不会出现在渲染树中，所以对于不常用的资源可以选择使用这个属性。**
2、对于每个可见的节点，为其匹配CSSOM规则并应用它们。
3、发射可见节点，连同其内容和计算的样式。

**visibility:hidden与display:none的区别**
前者是隐藏元素，但元素仍占据着布局空间（即将其渲染成一个空旷），而后者将元素从渲染树中完全移除，元素即不可见，也不是布局的组成部分。

**有了渲染树，接下来就是进入布局阶段（自动重排）**

为了弄清每个对象在网页上确切的大小和位置，浏览器从渲染树的根节点开始遍历。布局流程的输出是一个“盒模型”，它会精确地捕获每个元素在窗口内的确切位置和尺寸，即所有相对测量值都转换为屏幕上的绝对像素。

当节点和计算样式等几何信息排列好后，就会执行最后一个阶段，将渲染树中的每个节点转换成屏幕上的实际像素。这一步通常称为“绘制”或“栅格化”

**DevTools**
- Layout事件在时间线中捕获渲染树构建以及位置和尺寸计算。
- 布局完成后，浏览器会立即发出“Paint Setup”和“Paint”事件，将渲染树转换成屏幕上的像素。

######　渲染的时间长度来源
**执行渲染树的构建、布局和绘制所需的时间将取决与文档的大小、应用的样式，以及运行文档的设备：文档越大，浏览器需要完成的工作就越多；样式越复杂，绘制需要的时间就越长（例如。单色的绘制开销就比阴影的计算和渲染开销要小）**

##### 浏览器缓存机制
**缓存的意义**
> 网络获取内容会依赖网络环境同时开销巨大。客户端与服务器多次得往返通信，需要浏览器不停的去处理和获得内容，同时也会增加用户的流量费用。因此，缓存并重复利用之前就获取得资源对于性能优化会有很大得帮助。
> 
**制定缓存策略**
- 如果要缓存，网址要确保一致
- 确保服务器提供验证令牌（ETag）:有了验证令牌，当服务器资源未发生变化时，就不需要传送相同的字节。
- 确定中间缓存可以缓存哪些资源：对所有用户的响应完全相同的资源非常合适由CDN以及其他中间缓存进行缓存。
- 为每个资源确定最佳缓存周期：不同的资源可能有不同的更新需求，为每个资源审核并确定合适的max-age
- 确定合适你的网站的缓存层次结构。
- 区分资源变动的资源：将频繁变动的资源和不是很频繁的资源区分开来。

*背景*
> 缓存是性能优化中简单高效的优化方式，它可以显著减少网络传输所带来的消耗。


**HTTP缓存**
> 是日常开发中最为熟悉得一种缓存机制。，分为强缓存和协商缓存。强缓存优先级高于协商缓存

- 强缓存
Expires和Cache-Control两个相关字段。
命中强缓存，返回得HTTP状态码为200， 同时你会看到状态码后面会接一个**(from disk cache)或者(from memory cache)**。
```
Expires: Fri, 04 May 2029 11:37:22 GMT
```
我们可以看到Expires是一个时间戳，浏览器只能取到本地时间，如果用本地时间去对比肯定是有问题的，因为我们是可以修改客户端的时间的。所以HTTP1.1新增了**Cache-Control**字段来替代Expires.所以Cache-Control的优先级要高。
```
Cache-Control: max-age=315360000
```
我们可以通过max-age来控制资源得有效期。max-age是一个时间长度，上面即表示315360000秒。当 Cache-Control 与 expires 同时出现时，我们以 Cache-Control 为准。

**Cache-Control的其它值**
*max-age=<seconds>*
> 设置缓存时间，设置单位为秒，本地缓存和共享缓存都可以

*s-maxage*
> s-maxage的优先级高于max-age.主要用于代理服务器中。客户端我们只用max-age就行。并且s-maxage只对public缓存有效。

*public与private得区别*
设置为public时，既可以被浏览器缓存，也可以被代理服务器缓存。设置为private时，只能被浏览器缓存，并且private为默认值。

*no-store和no-cache的区别*
设置了no-cache后，请求时浏览器不会询问缓存得情况，而是直接请求服务器是否该资源过期。

设置了no-store后，不会使用任何缓存策略。连同服务端得缓存策略也绕开了。直接下载最新的资源。

*immutable*
> 表示文档是不能修改的

*must-revalidate*
> 表示客户端必须检测代理服务器上是否存在，即使已经缓存到了本地也要检查

*proxy-revalidate*
> 表示共享缓存（CDN）必须要检测源是否存在，即使已经有缓存

**实例说明**
Cache-Control: public max-age=3600  //本地缓存和CDN缓存1小时
Cache-Control: private immutable //不能缓存在CDN 只能本地缓存 并且一旦被缓存就不能修改
Cache-Control: no-cache  //不能缓存。 如果一定要缓存的话，确保对其进行二次验证
Cache-Control: public max-age=3600 s-maxage=7200 //本地缓存1小时  CDN上缓存两小时
Cache-Control: public max-age=3600 proxy-revalidate 本地和CDN都缓存1小时。但是如果CDN收到请求，则尽管已经缓存了1小时，还是要检测源中文档是否已经被改变


- 协商缓存
> 通过协商两个字就知道，功能需要协商才能定夺。协商缓存就是依赖于服务端与浏览器之间得通信。协商缓存机制下，浏览器需要向服务器咨询缓存得相关信息，进而判断是重新发起请求、下载完整得响应，还是从本地获取缓存得资源。

**如果服务端提示缓存资源未改动（Not Modified）**,资源就会被重定向到浏览器缓存，这时候网络请求对应得状态码是304.

*Last-Modified和Etag*
```
last-modified: Fri, 11 Jan 2019 01:54:59 GMT
```
last-modified也是一个时间戳。通过Response Headers返回。随后的请求，会带上一个叫if-modified-since的时间戳，也就是上一次response返回的lasr-modified值。服务器接受这个时间戳后，会对比该时间戳和资源在服务器上得最后修改时间是否一致，从而判断资源是否发生了变化。如果变化了则会返回最新请求并返回最新的last-modified值。
**使用last-modified的弊端**
1、虽然客户端有改变，但是不想重新请求，而服务端根据时间判断需要重新响应，这样就会达不到效果。
2、如果客户端修改时间比较短，比if-modified-since（只能以秒为单位）返回的时间还要短。则会出现想重新请求却不会请求得情况。

**Etag**
> 由服务器为每个资源生成得唯一得标识字符串，原理是基于文件内容编码得，只要文件内容不同，对用的值就不一样。
```
etag: W/"5715dcfb-171b"
```
首次请求时，会在响应头里获取一个最初得标识字符串，下一次请求时，请求头就会带上一个**if-None-Match**字符串供服务端对比。

**Etag得弊端**
服务器需要额外得开销来生成Etag,会影响到服务端得性能。Etag在感知文件变化上要比last-modified更加准确，优先级也更高。

**HTTP资源获取的流程图**
![cache](https://developers.google.cn/web/fundamentals/performance/optimizing-content-efficiency/images/http-cache-decision-tree.png)

步骤
1、资源是否复用，也就是判断这个请求需要实施缓存策略吗。no-store:不允许缓存响应，重新获取资源。
2、no-cache:启用缓存策略。private:只客户端缓存。public:代理服务器缓存。
3、然后通过max-age和s-maxage来判断资源是否过期。
4、最后看看是否有协商缓存，通过Tage以及last-modified来判断资源。

###### 获取缓存资源的几种方式
- Service Worker
  运行在浏览器背后的独立线程，如果要使用，传输协议必须为HTTPS，因为Service Worker中涉及到请求拦截，使用HTTPS协议来保障安全。
- Memory Cache
  所指是内存中的缓存，既然是内存中，优先级还是比较高的，所以浏览器会优先考虑将资源存储在内存中，响应速度也是很快的，但并不是所有资源都能够存储到内存中，一般图片以及部分HTML、CSS、JSS会存储，由于内存空间有限，很多比较大的文件还是直接存储硬盘。具体原理还是根据不同的浏览器来定夺。而且**Memory Cache会随着进程的结束而释放**。
- Disk Cache
  存储在硬盘上的缓存，对比Memmory Cache存储容量要大，存储时效也更长。而且相同地址的资源如果被缓存下来，即使是跨站点，也能共同使用。
- Push Cache
  1、属于HTTP/2中的特性，
  2、Edge和Safari兼容性一般。
  3、可以推送n0-cache和no-store得资源
  4、会话阶段的缓存，当 session 终止时，缓存也随之释放。



##### js综合资料

###### 虚拟滚动（[virtualized scroller](https://github.com/bvaughn/react-virtualized)）

怎么实现一次性把几万个ＤＯＭ全部插入？思路一：分批次插入，通过[request​Animation​Frame](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame)循环插入。
思路二：虚拟滚动：只渲染可视区域的内容，不可见区域的用户滚动的时候再渲染。

###### 重绘（Repaint）和回流（Reflow）


